# 原型继承
Child.prototype = new Parent();
实现本质就是重写原型对象，以一个新的实例代替
缺点：引用类型的属性被所有实例共享
# 借用构造函数继承
方法都在构造函数中定义，没有了函数复用，
 没有上一步 在子类里面 Person.call(this)
# 组合继承
 前两步都有额外加一个
Child.prototype.constructor = Child;
# 原型式继承
  在object中创建一个新的函数，新的函数原型对象指向参数对象，返回新函数的实例。
  本质上完成了一次浅复制。
  es5通过Object。create方法规范了原型式继承。
# 寄生继承
  Object.create(o);
  跟借用构造函数模式一样，每次创建对象都会创建一遍方法。
# 寄生组合式继承 
组合继承最大的缺点是会调用两次父构造函数。

借用构造函数来继承属性，通过原型链的混成形式来继承方法。


# 那什么是原型呢？
你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

区别：
ES5 和 ES6 子类 this 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，ES6 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。